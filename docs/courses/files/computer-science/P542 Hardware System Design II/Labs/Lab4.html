<html>

<!-- Mirrored from courses.enriqueareyan.com/files/computer-science/P542 Hardware System Design II/Labs/Lab4.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 12 Jan 2020 03:55:21 GMT -->
<head><title>Lab 4 - P542 Hardware System Design II - enriqueareyan.com</title></head>
<body>
      <h1>Lab 4</h1>
      <h2>Overview</h2>
<p>In this lab, you will be developing a driver for the <a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/DATASHEET/DM00027543.pdf">ST LSM303DLHC 3-Axis Accelerometer and Magnetometer</a>. This will initially involve bringing up the I2C communication interface connected to this device. One communication is established, data can be read from both the accelerometer and magnetometer which appear as separate I2C devices within the same package.</p>
<p>Drivers will be added for i2c (ds_i2c.c[h]), the accelerometer (ds_accel.c[h]), and the magnetometer (ds_mag.c[h]).</p>
<h2>I2C (ds_i2c.c[h])</h2>
<p>In this section, functions to initialize I2C1 will be created along with functions to read and write devices on the bus.</p>
<h2>I2C Functions</h2>
<h3>Initialization: ds_i2c1_init();</h3>
<ul>
<li>Identify the pins used for I2C1 from the schematic (note the processor pins connected to <span class="caps">SCL</span> and <span class="caps">SDA</span> on the LSM303DLHC).</li>
</ul><ul>
<li>Enable the clocks for <strong>I2C1</strong> and <strong><span class="caps">GPIO</span></strong> port.</li>
</ul><pre><code>RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE); 
RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOX, ENABLE);</code></pre>
<ul>
<li>
<span class="caps">SCL</span>/<span class="caps">SDA</span> configuration and assignment to the I2C: Configure these pins with the following properties. <strong>Do not forget to configure the proper alternate function number to assign these pins to the I2C1 peripheral.</strong>
</li>
</ul><ul>
<li>GPIO_Mode_AF</li>
		<li>GPIO_OType_PP</li>
		<li>GPIO_PuPd_DOWN</li>
		<li>GPIO_Speed_50MHz</li>
	</ul><ul>
<li>I2C1 Peripheral: Configure the I2C peripheral with the following parameters.</li>
</ul><pre><code>I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
I2C_InitStructure.I2C_DigitalFilter = 0x00;
I2C_InitStructure.I2C_OwnAddress1 = 0x00;
I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
I2C_InitStructure.I2C_Timing = 0x00902025;
I2C_Init(I2C1, &amp;I2C_InitStructure);
I2C_Cmd(I2C1, ENABLE);</code></pre>
<h3>Protocol:</h3>
<p>The I2C involves the following steps. Many of the steps involve data being read or written programmatically. However, some steps such as acknowledgement and multiple byte handled automatically by the I2C peripheral hardware. A STM32 peripheral library function named <a href="http://www.cs.indiana.edu/~bhimebau/f3lib/html/group__I2C.html#ga4ea3fec0b966564f8d45e5620384a96a">I2C_TransferHandling</a> will be used to manage the state of the I2C peripheral. This function manipulates to the I2C CR2 register.</p>
<p>This diagram shows the I2C bus transfers for the different types of transactions. <br><img src="../../../../SOIC-Digital-Systems/Spring-2013/wiki/images/protocol.001.html"></p>
<ul>
<li>
<b>ST:</b> The Start bit signifies the start of a bus transaction. It is generated by the I2C peripheral.</li>
	<li>
<b>RS:</b> Restart is a start bit that comes within the middle of a transaction. This allows the master to change from a write transfer to a read transfer within a single transaction with stopping and restarting. We will use this capability to write the address of the register that we would like to read from and then switch to a read transaction to pull over the data.</li>
	<li>
<b>Device|R:</b> I2C Device Address (Accel=0×32, Mag=0×3C). The address is shifted up by one bit and a R/W bit i s appended (read=1, write=0). The STM32 I2C peripheral handles this operation.</li>
	<li>
<b>Ack/Nack:</b> a device pulls the <span class="caps">SDA</span> line low to acknowledge the receipt of a byte of data. To end multiple byte read, the master will Nack (not-acknowlege) to signify that the transfer is over.</li>
	<li>
<b>M|Reg:</b> Specific register within the accel or mag that is going to be written or read. If the intent is to handle multiple bytes, then the <span class="caps">MSB</span> of the register number needs to be set programatically.</li>
	<li>
<b>Data:</b> One byte is transferred at a time and acknowledged.</li>
	<li>
<b>SP:</b> The Stop bit is generated by the I2C hardware. The read and write routines will test for the transmission of this bit to signify that the transaction is complete.</li>
</ul><h3>Read: void ds_i2c1_read(uint8_t device, uint8_t reg, uint8_t* buffer, uint16_t numbytes);</h3>
<p>This function will read multiple bytes into buffer from the I2C slave specified by <strong>device</strong> starting at the register address specified by <strong>reg</strong>.</p>
<ul>
<li>Wait for the I2C device to become available</li>
</ul><pre><code> while (I2C_GetFlagStatus(I2C1, I2C_ISR_BUSY) != RESET); </code></pre>
<ul>
<li>Send start bit and <strong>device</strong>. Wait for the transmitter to become empty.</li>
</ul><pre><code>I2C_TransferHandling(I2C1, device, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);
while (I2C_GetFlagStatus(I2C1, I2C_ISR_TXIS) == RESET);</code></pre>
<ul>
<li>If the read transfer is going to involve more than one byte, then set the <strong>multiple</strong> bit in the register address.</li>
</ul><pre><code>if (numbytes&gt;1) {
  reg |=0x80;                                                                             
}</code></pre>
<ul>
<li>Send <strong>reg</strong> and wait for the transfer to complete.</li>
</ul><pre><code>I2C_SendData(I2C1,reg);                    
while (I2C_GetFlagStatus(I2C1, I2C_ISR_TC) == RESET); </code></pre>
<ul>
<li>Setup the read of the data bytes from the device. This is a two step process.
	<ul>
<li>Initialize the transfer in the I2C peripheral to cause the proper acknowledgements and stop bit to be generated.</li>
		<li>Capture each byte as it arrives. The receiver status is polled to indicate the receipt of a byte.</li>
	</ul>
</li>
</ul><pre><code>I2C_TransferHandling(I2C1, device, numbytes, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
while (numbytes--) {
  while(I2C_GetFlagStatus(I2C1, I2C_ISR_RXNE) == RESET);
  *buffer++ = I2C_ReceiveData(I2C1);
}</code></pre>
<ul>
<li>Poll for the stop bit. The stop will be generated by the I2C hardware when the previous transfer is complete. The flag must be clear programatically.</li>
</ul><pre><code>while (I2C_GetFlagStatus(I2C1, I2C_ISR_STOPF) == RESET); 
I2C_ClearFlag(I2C1, I2C_ICR_STOPCF);</code></pre>
<h3>Write: void ds_i2c1_write(uint8_t device, uint8_t reg, uint8_t* value);</h3>
<p>This function will write a single byte to the device. It writes only a single byte because, it will be used to write one byte configuration registers within the the accel and mag.</p>
<ul>
<li>Wait for the I2C device to become available</li>
</ul><pre><code>while (I2C_GetFlagStatus(I2C1, I2C_ISR_BUSY) != RESET);</code></pre>
<ul>
<li>Send start bit and <strong>device</strong>. Wait for the transmitter to become empty.</li>
</ul><pre><code>I2C_TransferHandling(I2C1, device, 1, I2C_Reload_Mode, I2C_Generate_Start_Write);
while (I2C_GetFlagStatus(I2C1, I2C_ISR_TXIS) == RESET);</code></pre>
<ul>
<li>Send the register address, <strong>reg</strong>. Since only one byte will be transferred, the multiple bit does not need to be set.</li>
</ul><pre><code>I2C_SendData(I2C1,reg);
while(I2C_GetFlagStatus(I2C1, I2C_ISR_TCR) == RESET);</code></pre>
<ul>
<li>Setup the write transfer and poll to confirm that the transmitter is empty</li>
</ul><pre><code>I2C_TransferHandling(I2C1, device, 1, I2C_AutoEnd_Mode, I2C_No_StartStop);
while(I2C_GetFlagStatus(I2C1, I2C_ISR_TXIS) == RESET);</code></pre>
<ul>
<li>Send the payload</li>
</ul><pre><code>I2C_SendData(I2C1, *value);</code></pre>
<ul>
<li>Poll for the stop bit and reset it once it is set.</li>
</ul><pre><code>while(I2C_GetFlagStatus(I2C1, I2C_ISR_STOPF) == RESET);
I2C_ClearFlag(I2C1, I2C_ICR_STOPCF);</code></pre>
<p>This completes the initialization of the I2C peripheral and the creation of the bus read and write functions. These function will now be used to initialize and read data from the accelerometer and magnetometer.</p>
<h2>Accelerometer Device <strong>0×32</strong> (ds_accel.c[h])</h2>
<p>The accelerometer measures acceleration in the X, Y, and Z axis in G - where 1G is the resting force due to gravity.</p>
<h3>Initialization: void ds_accel_init()</h3>
<p>The initialization will write 3 control registers within the accelerometer.</p>
<ul>
<li>Ctrl Reg1 (reg=0×20), value=0×47</li>
	<li>Ctrl Reg2 (reg=0×21), value=0×90</li>
	<li>Ctrl Reg4 (reg=0×23), value=0×08</li>
</ul><h3>Reading Data: void ds_accel_read(float *accel_data)</h3>
<p>Similar to the gyro, the accelerometer store the data for each axis in two adjacent bytes. The data for the X axis starts at register 0×28. The 6 bytes will be read and converted into a floating point number based on the full-scale range of the device.</p>
<ul>
<li>Use the read function that you created earlier to read 6 bytes of data starting at reg 0×28 from the accelerometer (device=0×32).</li>
</ul><ul>
<li>Conversion to a floating point number</li>
</ul><pre><code>for (i=0; i&lt;3; i++) {
  raw_data[i]=((int16_t)((uint16_t)buffer[2*i+1] &lt;&lt; 8) + buffer[2*i])/(uint8_t)16;
  accel_data[i]=(float)raw_data[i]/1000.0;
}</code></pre>
<h2>Magnetometer Device <strong>0×3C</strong> (ds_mag.c[h])</h2>
<p>The magnetometer measures the magnetic field in the X, Y, and Z axis in Gauss. A typical use for this type of sensor is to measure the earth's magnetic field in a compass application.</p>
<h3>Initialization: void ds_mag_init()</h3>
<p>The initialization will write 3 control registers within the accelerometer.</p>
<ul>
<li>
<span class="caps">CRA</span> (reg=0×00), value=0×14</li>
	<li>
<span class="caps">CRB</span> (reg=0×01), value=0xE0</li>
	<li>MR  (reg=0×02), value=0×00</li>
</ul><h3>Reading Data: void ds_mag_read(float *accel_data)</h3>
<p>The magnetometer is similar to the gyro and accel in the way that it stores the axis data in 6 registers. However, they added a wrinkle and placed the Z axis between X and Y. Additionally, a different conversion factor is used for the Z axis.</p>
<ul>
<li>Read the bytes from the device (0×3C) where the data for X starts at 0×03, Y starts at 0×07, and Z starts at 0×05.</li>
</ul><pre><code>ds_i2c1_read(0x3C, 0x03, buffer,2);   // Read X Axis
ds_i2c1_read(0x3C, 0x07, buffer+2,2); // Read Y Axis
ds_i2c1_read(0x3C, 0x05, buffer+4,2); // Read Z Axis (notice that Z is out of order in the chip).</code></pre>
<ul>
<li>Conversion to a floating point number. Note that the Z axis uses a different conversion factor.</li>
</ul><pre><code>for (i=0; i&lt;2; i++) {
  mag_data[i]=(float)((int16_t)(((uint16_t)buffer[2*i] &lt;&lt; 8) + buffer[2*i+1]))/230;
}
mag_data[2]=(float)((int16_t)(((uint16_t)buffer[4] &lt;&lt; 8) + buffer[5]))/205;</code></pre>
<h2>Assignment</h2>
<ul>
<li>Use the accelerometer data to compute the tilt angle of the board. This <a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/APPLICATION_NOTE/CD00268887.pdf">ST application note</a> is a good reference for this computation.</li>
</ul><ul>
<li>Extend your gyro code from lab 3 to also output the current tilt angle for the selected axis on the console.</li>
</ul><h2>What to Turn in:</h2>
<p>This assignment is due by midnight on <b>2/7</b>. At midnight, your AI will pull the current state of your repository to review your code. In the following lab session, you will be asked to demonstrate your solution. Independently, you will also write a lab report describing in approximately 300 words or less the following:</p>
<ul>
<li>Description of your solution.</li>
	<li>Description of issues that you encountered in developing your solution.</li>
	<li>Two preliminary project ideas that your team is considering.</li>
</ul><p>You will turn in this lab report in the oncourse assignments section.</p>
    </div>
  </div>
  </div>

</div>
<div id="gollum-footer">
  <p id="last-edit">
    Last edited by Bryce Himebaugh, <time class="js-relative-date" datetime="2013-02-01T07:38:26-05:00" title="2013-02-01 07:38:26">February 01, 2013</time>
  </p>
</body>

<!-- Mirrored from courses.enriqueareyan.com/files/computer-science/P542 Hardware System Design II/Labs/Lab4.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 12 Jan 2020 03:55:23 GMT -->
</html>  